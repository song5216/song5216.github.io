---
title: "凤凰架构"
date: 2026-02-18T21:47:50+08:00
draft: false
tags: ["架构"]
categories: []
description: ""
cover:
    image: ""
    alt: ""
    caption: ""
    relative: false
---

# 类库与服务

服务化的目标，是把系统拆分为可以**独立演进、独立部署、独立自治**的组件；而类库/模块化更多是**代码层面的复用与拆分**。

两者的关键差异在于：

- **类库调用发生在进程内**：接口调用通过编译期静态链接与运行期地址引用完成，本质上是一次本地函数调用，不涉及网络传输。
- **服务调用跨进程/跨主机**：接口调用需要序列化与网络传输，必须面对延迟、失败、重试、超时等分布式问题。

因此：

- **类库升级通常需要重新编译并发布应用整体**。
- **服务可以独立升级与发布**，调用方通过契约（接口/协议）进行解耦。

## 服务化需要解决的三类基础问题

当系统走向服务化，最先要补齐的是三类基础能力：**服务发现、网关路由、负载均衡**。

- **服务发现**：调用方如何获知“被调用服务在哪里”。
- **网关/路由**：请求如何抵达正确的服务实例，以及如何做统一入口治理（鉴权、限流、灰度等）。
- **负载均衡**：当存在多个等价实例时，如何在它们之间分摊请求。

## 1. 服务发现

### 1.1 标识方式

一个服务实例通常由 **主机标识（域名/IP）+ 端口** 唯一确定。

最简单的服务发现方式是 **DNS**：将域名解析为 IP（并可能返回多个地址），客户端再结合端口完成访问。

当系统需要支持**实例上下线、故障切换、扩缩容、重启**等动态变化时，通常需要更强的注册与发现机制，让调用方能够及时感知实例变化。

### 1.2 注册中心的可用与可靠

- **可用（Availability）**：注册中心本身功能是否可用、能否持续对外提供查询与注册能力。
- **可靠（Reliability）**：注册的服务数据是否准确、一致，能否避免“脏数据”导致的错误路由。

常见保障手段：

- **高可用**：多副本部署、故障转移。
- **一致性**：通过一致性协议（如 Paxos/Raft）保证数据一致。

### 1.3 注册中心的常见实现

1. 基于分布式 K/V 存储或协调系统构建，例如 `ZooKeeper`。
2. 专用的服务发现/注册中心产品或组件，例如 `Eureka`、`Consul`、`Nacos`。
3. 基于基础设施能力实现，例如 `DNS`（更轻量，但动态能力相对有限）。

## 网关路由

### 1.1 网关的职责

网关（Gateway）的核心价值，是作为系统对外的**统一入口**：外部请求先到达网关，网关再依据既定规则将流量转发到内部集群中**正确的服务实例**。因此它也常被称为**服务网关**或 **API 网关**。

从能力拆分的角度看，网关通常由两类职能构成：

- **路由（Router，基础能力）**：把请求“转发到哪里、以什么方式转发”。
- **过滤/治理（Filter，增强能力）**：在转发前后做统一处理，例如鉴权、限流、熔断、灰度、日志、指标、协议转换等。

其中，路由能力的设计通常需要优先回答三个问题：**协议层次、性能、可用性**。

#### 1）协议层次：四层网关 vs 七层网关

网关工作在不同协议层，决定了它能理解请求到什么程度，也决定了转发成本与可扩展性。

1. **四层网关（L4）**：面向 TCP/UDP 等传输层协议做转发（常见做法是基于连接/端口的转发）。
   - **适用**：后端服务对上层协议不敏感或无需做应用层治理。
   - **特点**：转发开销小、性能强，但难以做丰富的应用层策略。
2. **七层网关（L7）**：面向 HTTP/HTTPS/gRPC 等应用层协议做代理与转发。
   - **适用**：需要基于 URL/Header/Cookie/方法等请求特征做路由与治理。
   - **特点**：能力更强但成本更高，需要处理解析、编解码、连接复用等问题。

> 注：原文中的 “TPC” 应为 “TCP”。

#### 2）性能：转发模型与实现策略

网关性能主要受两类因素影响：

- **工作模式**：L4 转发还是 L7 代理（后者需要解析与处理应用层语义，CPU 与内存成本更高）。
- **实现策略**：连接管理、线程模型、I/O 模型、缓存与零拷贝等。

在以 HTTP 为主的互联网服务场景中，通常需要使用 **L7 代理网关** 来承载丰富的路由与治理能力；因此，进一步影响性能上限的关键，就落在**网络 I/O 模型**与并发模型设计上（见后文 `1.2 网络 IO 模型`）。

#### 3）可用性：轻量、成熟、可扩展

- **保持轻量**：把复杂业务逻辑下沉到后端服务，网关尽量专注在“路由 + 治理”，避免成为新的单点瓶颈。
- **优先成熟方案**：选型尽量选择经过大规模验证的产品与实现，降低故障概率与运维成本。
- **分层承载流量入口**：在生产环境中常在网关前增加一层更健壮的入口设施（如硬件/云负载均衡、等价路由器），承担四层接入与流量分发；网关本身再通过**横向扩展**提升整体吞吐与可用性。

### 1.2 网络 IO 模型

网关在七层代理模式下，本质上是一个高并发的网络程序：它需要在**有限线程/连接资源**下，尽可能高效地处理大量短连接或长连接请求。因此，网关的性能上限很大程度取决于所采用的网络 I/O 模型。

从语义上看，I/O 模型的差异主要体现在两点：

- **等待数据就绪（ready）时是否阻塞**：没有数据可读/不可写时，线程要不要挂起。
- **数据搬运（copy）由谁完成**：是内核把数据拷贝到用户缓冲区后再唤醒应用，还是应用自己发起异步回调/通知。

#### 异步 I/O（Asynchronous I/O，AIO）

应用提交 I/O 请求后**立即返回**，不需要阻塞等待；当内核完成数据读取并拷贝到用户态缓冲区后，再通过**回调/事件**通知应用继续处理。

- **优点**：线程占用少，适合高并发；理论上吞吐上限更高。
- **难点**：编程模型更复杂；不同平台/语言运行时对 AIO 的支持成熟度不一。
- **常见形态**：基于事件回调或 Future/Promise 的异步网络框架。

#### 同步 I/O（Synchronous I/O）

同步 I/O 的共同点是：应用线程在某个阶段需要等待 I/O 完成（至少会等待“数据就绪”或“拷贝完成”之一）。典型划分如下。

1. **阻塞 I/O（Blocking I/O）**
   - `read()` 没有数据时会阻塞线程，直到数据到达并完成拷贝。
   - **特点**：模型简单，但每连接/每请求容易占用一个线程，扩展性差。

2. **非阻塞 I/O（Non-blocking I/O）**
   - `read()` 立即返回，若无数据则返回 `EAGAIN`/`EWOULDBLOCK`，应用需要不断轮询重试。
   - **特点**：不会挂死线程，但轮询会浪费 CPU；通常不会单独使用。

3. **I/O 多路复用（I/O Multiplexing）**
   - 通过 `select/poll/epoll`（或同类机制）让一个线程同时监听多个连接的可读/可写事件；当事件就绪后再执行真正的 `read/write`。
   - **特点**：经典的高并发方案，性能与资源利用率均衡；绝大多数高性能网关/反向代理都基于此类模型。

4. **信号驱动 I/O（Signal-driven I/O）**
   - 内核通过信号通知某个 fd 已就绪，应用收到信号后再执行读写。
   - **特点**：工程实践较少，主要原因是信号处理复杂、可控性与可移植性一般。

> 经验上：
> - 简单服务可用阻塞 I/O 快速实现；
> - 要支撑高并发网关，常见路线是“多路复用 + 少量工作线程”的 Reactor 模型；
> - 若语言/运行时对异步生态成熟（如事件循环），可以用异步 I/O 进一步提升并发能力与资源利用率。




技术实现上，从路由器的角度，网关和负载均衡器没有本质区别；但从目的角度，负载均衡器是对实例流量的平均路由，网关是结合网络请求的特征，进行正确的路由。

1. **统一网关路由**：网关作为独立组件对外提供统一入口（天然跨网络调用）。
2. **客户端路由**：路由逻辑在客户端/SDK 中完成（通常与调用方进程内集成）。
3. **边车路由（Sidecar）**：以边车形式部署（例如在 K8s 体系中），从控制面获取服务与路由配置并执行转发。
